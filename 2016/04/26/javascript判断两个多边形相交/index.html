<!DOCTYPE html><html lang="zh-cmn-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> javascript判断两个多边形相交 · Ken's Blog － 黄凯羿的个人博客，分享javascript,前端开发,设计和生活。</title><meta name="description" content="javascript判断两个多边形相交 - Ken Huang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">分类</a></li><li class="nav-list-item"><a href="http://weibo.com/witnesswithyou" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/kenhky" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://www.huangkaiyi.com" target="_blank" class="nav-list-link">主页</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">javascript判断两个多边形相交</h1><div class="post-time">Apr 26, 2016</div><div class="post-content"><p>最近在业务中有个需求是用高德api绘制多个多边形，且多边形不能有重合的地方。高德并没有提供这种api，所以自己尝试着实现了一个算法。</p>
<p>判断两个多边形是否相交，首先从业务需求来想，最多的情况肯定是两个多边形不相交，从这个角度想的话，有什么情况下两个多边形一定不相交呢？打个比方：有一本书，书的平面下方放着你的手机，你的书的最下一的个点是不是比你手机最上一个点还要高？这种情况很容易判断，所以我们先写算法把他排除。<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/book.png" alt=""></p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//极值判断两多边形不相交</span></div><div class="line"><span class="keyword">var</span> shape1= [&#123;<span class="string">"x"</span>:<span class="number">1</span>,<span class="string">"y"</span>:<span class="number">3</span>&#125;,&#123;<span class="string">"x"</span>:<span class="number">3</span>,<span class="string">"y"</span>:<span class="number">3</span>&#125;,&#123;<span class="string">"x"</span>:<span class="number">3</span>,<span class="string">"y"</span>:<span class="number">2</span>&#125;,&#123;<span class="string">"x"</span>:<span class="number">1</span>,<span class="string">"y"</span>:<span class="number">2</span>&#125;];</div><div class="line"><span class="keyword">var</span> shape2= [&#123;<span class="string">"x"</span>:<span class="number">1</span>,<span class="string">"y"</span>:<span class="number">1</span>&#125;,&#123;<span class="string">"lat"</span>:<span class="number">2</span>,<span class="string">"lng"</span>:<span class="number">2</span>&#125;,&#123;<span class="string">"lat"</span>:<span class="number">3</span>,<span class="string">"lng"</span>:<span class="number">1</span>&#125;];</div><div class="line"><span class="keyword">var</span> checkTwoPolygonByDirection = <span class="function"><span class="keyword">function</span> (<span class="params">polygon1,polygon2</span>) </span>&#123;</div><div class="line">    <span class="comment">//得到一个多边形的极值数组［左，上，右，下］</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDirection</span>(<span class="params">shape</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> shapeEastAndWest = [],shapeSourceAndNorth = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shape.length; i++) &#123;</div><div class="line">            shapeEastAndWest.push(shape[i].x);</div><div class="line">            shapeSourceAndNorth.push(shape[i].y);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span>[<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,shapeEastAndWest),<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,shapeSourceAndNorth),<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,shapeEastAndWest),<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,shapeSourceAndNorth)]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> direction1=getDirection(polygon1),direction2=getDirection(polygon2);</div><div class="line">    <span class="keyword">if</span> (direction1[<span class="number">0</span>]&gt;direction2[<span class="number">2</span>]||direction1[<span class="number">2</span>]&lt;direction2[<span class="number">0</span>]||direction1[<span class="number">1</span>]&lt;direction2[<span class="number">3</span>]||direction1[<span class="number">3</span>]&gt;direction2[<span class="number">1</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;;</div><div class="line">checkTwoPolygonByDirection(shape1,shape2);</div></pre></td></tr></table></figure>
</code></pre><p>排除了最多的情况以后，我们就要开始探寻两个多边形相交的算法了。两多边形相交，其中肯定有一个多边形的点在另一个多边形里。我们先往这个方向探寻。</p>
<p>判断一个点是否在多边形内，有一个很有意思的理论。想象有一个点在多边形内，这个点朝任意方向射出一条射线，无论多边形是什么形状，射线经过的点都是奇数。我在前端乱炖上看到一篇文章，讲了射线法的写法和特殊情况的处理，原文地址<a href="http://www.html-js.com/article/1528" target="_blank" rel="external">http://www.html-js.com/article/1528</a>（米粽粽）。</p>
<p>简单的说，点在多边形内的判断有4种特殊情况，1.点在多边形边上，2.点和多边形顶点重合，3.射线经过多边形顶点，4.射线刚好经过多边形的一条边。<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/Slice%201.png" alt=""><br>1，2都很简单，具体可以看原文。3，4的话仔细想一想，判断射线有没有穿过线段其实就是判断线段两个端点分别在射线两侧，假如我们规定射线经过的点都属于射线以上的一侧，如图所示：<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/shexian.png" alt=""><br>线段ab顶点和线段ae顶点对于射线1来说都在两侧，所以射线1穿过了两条线段。线段ab顶点都在射线2上侧，线段bc顶点在射线2两侧，所以射线2穿过了线段bc。我们可以得出点1在多边形外，点2在多边形内。</p>
<p>特殊情况4其实和3是一样的，根据上面的假设，射线连续经过的两个顶点显然都位于射线以上的一侧，因此这种情况看作没有发生穿越就可以了。由于3实际上已经覆盖到这种特例，因此不需要再做特别的处理。</p>
<p>最后我们得出的代码如下：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多边形顶点判断多边形相交</span></div><div class="line"><span class="keyword">var</span> checkTwoPolygonByRay = <span class="function"><span class="keyword">function</span> (<span class="params">polygon1,polygon2</span>) </span>&#123;</div><div class="line">    <span class="comment">//判断多边形顶点在另一个多边形里</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rayCasting</span>(<span class="params">p, poly</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> px = p.x,</div><div class="line">            py = p.y,</div><div class="line">            flag = <span class="literal">false</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = poly.length, j = l - <span class="number">1</span>; i &lt; l; j = i, i++) &#123;</div><div class="line">            <span class="keyword">var</span> sx = poly[i].x,</div><div class="line">                sy = poly[i].y,</div><div class="line">                tx = poly[j].x,</div><div class="line">                ty = poly[j].y</div><div class="line"></div><div class="line">            <span class="comment">// 点与多边形顶点重合</span></div><div class="line">            <span class="keyword">if</span>((sx === px &amp;&amp; sy === py) || (tx === px &amp;&amp; ty === py)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 判断线段两端点是否在射线两侧</span></div><div class="line">            <span class="keyword">if</span>((sy &lt; py &amp;&amp; ty &gt;= py) || (sy &gt;= py &amp;&amp; ty &lt; py)) &#123;</div><div class="line">                <span class="comment">// 线段上与射线 Y 坐标相同的点的 X 坐标</span></div><div class="line">                <span class="keyword">var</span> x = sx + (py - sy) * (tx - sx) / (ty - sy)</div><div class="line">                <span class="comment">// 点在多边形的边上</span></div><div class="line">                <span class="keyword">if</span>(x === px) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 射线穿过多边形的边界</span></div><div class="line">                <span class="keyword">if</span>(x &gt; px) &#123;</div><div class="line">                    flag = !flag</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 射线穿过多边形边界的次数为奇数时点在多边形内</span></div><div class="line">        <span class="keyword">return</span> flag</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; polygon1.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (rayCasting(polygon1[i],polygon2)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; polygon2.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (rayCasting(polygon2[i],polygon1)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p>上面这段代码有什么问题呢？我发现两多边形相交的话其中一个多边形的所有顶点不一定在另一个多边形内，所以我们两个多边形都得遍历一遍，在最坏的情况下性能很差。我们有没有什么办法能用更少时间复杂度的方法来计算呢？</p>
<p>两多边形相交的话是不是一定有两条边相交呢？计算两直线相交有很多种办法，比如利用叉乘，比如利用计算点和线段构成的三角形面积等。</p>
<p>判断两条线相交，需要判断每一条线的两个端点分别在另一条线的两端。通过建立向量，计算叉乘来判断两个值的正负来判断是否在线段两边。具体理论可以看<a href="http://www.html-js.com/article/1183" target="_blank" rel="external">http://www.html-js.com/article/1183</a>（芋头）。</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//两条线相交判断多边形相交</span></div><div class="line"><span class="keyword">var</span> checkTwoPolygonByintersect=<span class="function"><span class="keyword">function</span> (<span class="params">polygon1,polygon2</span>) </span>&#123;</div><div class="line">    <span class="comment">//计算向量叉乘</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">crossMul</span> (<span class="params">v1,v2</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span>   v1.x*v2.y-v1.y*v2.x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//计算两条线是否相交</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkCross</span> (<span class="params">p1,p2,p3,p4</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> (checkTwoCross(p1,p2,p3,p4)&lt;=<span class="number">0</span>&amp;&amp;checkTwoCross(p3,p4,p2,p1)&lt;=<span class="number">0</span>)?<span class="literal">true</span>:<span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//计算两个向量叉乘相乘是否为负 </span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkTwoCross</span> (<span class="params">p1,p2,p3,p4</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> v1=&#123;<span class="attr">x</span>:p1.x-p3.x,<span class="attr">y</span>:p1.y-p3.y&#125;,</div><div class="line">        v2=&#123;<span class="attr">x</span>:p2.x-p3.x,<span class="attr">y</span>:p2.y-p3.y&#125;,</div><div class="line">        v3=&#123;<span class="attr">x</span>:p4.x-p3.x,<span class="attr">y</span>:p4.y-p3.y&#125;,</div><div class="line">        v=crossMul(v1,v3)*crossMul(v2,v3);</div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = polygon1.length, j = l<span class="number">-1</span>; i &lt; l; j=i, i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i2 = <span class="number">0</span>, l2 = polygon2.length, j2 = l2<span class="number">-1</span>; i2 &lt; l; j2=i2, i2++) &#123;</div><div class="line">            <span class="keyword">if</span> (checkCross(polygon1[i],polygon1[j],polygon2[i2],polygon2[j2])) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p>还有很多种方法判断两直线相交，比如点和线段构成的三角形面积。已知三角形三点a(x,y) b(x,y) c(x,y)，三角形面积为：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> triArea=( (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x) ) /<span class="number">2</span> ;</div></pre></td></tr></table></figure>
</code></pre><p>如果线段ab和点c构成的三角形面积与线段ab和点d构成的三角形面积构成的三角形面积的正负符号相异, 那么点c和点d位于线段ab两侧.<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/triangle.png" alt=""><br>感兴趣的可以自己实现。</p>
<p>通过两条线相交来判断多边形相交有什么缺点呢？其实有一种特殊情况我们没有想到过，那就是当一个多边形在另一个多边形内怎么办？难道我们还是得回到原来通过多边形的一个顶点在另一个多边形内来判断么？</p>
<p>不，既然这种算法更优，我们再想办法来覆盖特殊情况。一个多边形在另一个多边形内有一个必要非充分条件，和我们在文章开头读到的算法相似。当多边形a在多边形b内时，多边形b的四个极点都比多边形a大。那我们就可以通过这个条件来减少我们算法的时间复杂度，当满足这个条件时再判断一个多边形是否有个点在另一个多边形内。<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/insert.png" alt=""><br>我们把开头的算法改造如下：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方向相离判断两多边形不相交</span></div><div class="line"><span class="keyword">var</span> checkTwoPolygonByDirection = <span class="function"><span class="keyword">function</span> (<span class="params">polygon1,polygon2</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDirection</span>(<span class="params">shape</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> shapeEastAndWest = [],shapeSourceAndNorth = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shape.length; i++) &#123;</div><div class="line">            shapeEastAndWest.push(shape[i].lat);</div><div class="line">            shapeSourceAndNorth.push(shape[i].lng);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>[<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,shapeEastAndWest),<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,shapeSourceAndNorth),<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,shapeEastAndWest),<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,shapeSourceAndNorth)]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> direction1=getDirection(polygon1),direction2=getDirection(polygon2);</div><div class="line">    <span class="keyword">if</span> (direction1[<span class="number">0</span>]&gt;direction2[<span class="number">2</span>]||direction1[<span class="number">2</span>]&lt;direction2[<span class="number">0</span>]||direction1[<span class="number">1</span>]&lt;direction2[<span class="number">3</span>]||direction1[<span class="number">3</span>]&gt;direction2[<span class="number">1</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [direction1,direction2]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p>然后完成我们完整的算法：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断两多边形是否相交</span></div><div class="line"><span class="keyword">var</span> checkTwoPolygon = <span class="function"><span class="keyword">function</span> (<span class="params">shape1,shape2</span>) </span>&#123;</div><div class="line">    <span class="comment">//通过极点判断是否相离，相离return true，否则return[多边形1的极点数组，多边形2的极点数组]</span></div><div class="line">    <span class="keyword">var</span> directions = checkTwoPolygonByDirection(shape1,shape2);</div><div class="line">    <span class="keyword">if</span> (directions == <span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通过直线相交来判断多边形是否相交</span></div><div class="line">    <span class="keyword">if</span> (checkTwoPolygonByintersect(shape1,shape2)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通过多边形1的极点都比多边形2的极点小或者都比多边形2的极点大来进入 通过多边形的顶点在另一个多边形内的算法</span></div><div class="line">    <span class="keyword">if</span> ((directions[<span class="number">0</span>][<span class="number">0</span>]&lt;directions[<span class="number">1</span>][<span class="number">0</span>]&amp;&amp;directions[<span class="number">0</span>][<span class="number">1</span>]&gt;directions[<span class="number">1</span>][<span class="number">1</span>]&amp;&amp;directions[<span class="number">0</span>][<span class="number">2</span>]&gt;directions[<span class="number">1</span>][<span class="number">2</span>]&amp;&amp;directions[<span class="number">0</span>][<span class="number">3</span>]&lt;directions[<span class="number">1</span>][<span class="number">3</span>])||(directions[<span class="number">1</span>][<span class="number">0</span>]&lt;directions[<span class="number">0</span>][<span class="number">0</span>]&amp;&amp;directions[<span class="number">1</span>][<span class="number">1</span>]&gt;directions[<span class="number">0</span>][<span class="number">1</span>]&amp;&amp;directions[<span class="number">1</span>][<span class="number">2</span>]&gt;directions[<span class="number">0</span>][<span class="number">2</span>]&amp;&amp;directions[<span class="number">1</span>][<span class="number">3</span>]&lt;directions[<span class="number">0</span>][<span class="number">3</span>])) &#123;</div><div class="line">        <span class="keyword">return</span> checkTwoPolygonByRay(shape1,shape2)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p>这个并不完美的算法就算完成了，它还有很多不完美的地方，如果大家有什么更好的idea欢迎联系我.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/05/05/几种方法export你的模块-兼容AMD-CommonJS-Node-js等/" class="prev">PREV</a></div><div class="copyright"><p>© 2016 - 2017 <a href="http://www.huangkaiyi.me">Ken Huang</a> 粤ICP备15066407号 邮箱:ken.hky@163.com</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>