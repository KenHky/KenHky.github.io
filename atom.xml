<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ken&#39;s Blog － 黄凯羿的个人博客，分享javascript,前端开发,设计和生活。</title>
  <subtitle>黄凯羿的个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.huangkaiyi.me/"/>
  <updated>2017-05-25T07:13:14.000Z</updated>
  <id>http://www.huangkaiyi.me/</id>
  
  <author>
    <name>Ken Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>geek向的打字机效果实现</title>
    <link href="http://www.huangkaiyi.me/2017/05/25/geek%E5%90%91%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.huangkaiyi.me/2017/05/25/geek向的打字机效果实现/</id>
    <published>2017-05-25T10:07:00.000Z</published>
    <updated>2017-05-25T07:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>css 揭秘这本书买了好久了，一直没有看完。趁着有空翻了一遍，有一个效果吸引到了我，就是类似终端的打字机效果。</p>
<p><img src="http://7xtb3a.com2.z0.glb.clouddn.com/type-writer.gif" alt=""></p>
<p>要实现这个效果，最简单的就是用 javascript setInterval 来不断改变字符串的位数来实现。</p>
<p>比如： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typewriter</span> (<span class="params">typeDom</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> n = <span class="number">0</span>;</div><div class="line">	<span class="keyword">var</span> text = typeDom.textContent;</div><div class="line">	<span class="comment">// 初始内容设空</span></div><div class="line">	typeDom.innerHTML = <span class="string">''</span>;</div><div class="line">	<span class="comment">// setInterval 改变字符串的位数</span></div><div class="line">	<span class="keyword">var</span> print = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	  n += <span class="number">1</span>;</div><div class="line">	  typeDom.innerHTML = text.substring(<span class="number">0</span>, n);</div><div class="line">	  <span class="keyword">if</span> (n === text.length) &#123;</div><div class="line">			<span class="built_in">window</span>.clearInterval(print);</div><div class="line">		&#125;</div><div class="line">	&#125;, <span class="number">200</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> typist = <span class="built_in">document</span>.querySelectorAll(<span class="string">".typist"</span>);</div><div class="line">typewriter(typist[<span class="number">0</span>])</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"typist"</span>&gt;</span>你好，这是一个打字效果动画<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>动画效果归根结底是表现层的，那能不能直接用 css 实现呢？答案是可以的。</p>
<p>首先让文字从无到有，大家都能想到用 animation :</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> typing &#123;</div><div class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">width</span>: <span class="number">0</span> &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.typist</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">13em</span>; <span class="comment">/* 文本宽度 */</span></div><div class="line">  <span class="attribute">animation</span>: typing <span class="number">6s</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"typist"</span>&gt;你好，这是一个打字效果动画&lt;<span class="regexp">/p&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://7xtb3a.com2.z0.glb.clouddn.com/type-writer-wrong.gif" alt=""></p>
<p>这样实现有几个问题。</p>
<ol>
<li>文本未折行。</li>
<li>动画不是一个一个文字出来的，而是平滑连贯的。</li>
<li>没有光标。</li>
<li>在中文等宽字体中可以直接用em，英文怎么算宽度？</li>
</ol>
<p>我们一个一个解决：</p>
<p>第一个问题加上 <code>white-space: nowrap;</code>和<code>overflow: hidden;</code>就可以了。</p>
<p>第二个问题需要用到 css 动画的 animation-timing-function 这个属性。这个属性规定动画的速度曲线，其中提供了一个 steps() 函数来实现切割动画。 steps() 通过你传入的步骤数来切割动画，类似于幻灯片一样而不是默认平滑的效果。比如 steps(6) 就表示这个动画有6步。这个属性可以直接写到 animation 简写里，我们可以把上面的属性改写成：animation: typing 6s steps(13);</p>
<p>这两个问题解决了以后我们打字动画的雏形就已经完成了，完整 css 如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> typing &#123;</div><div class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">width</span>: <span class="number">0</span> &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.typist</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">13em</span>; <span class="comment">/* 文本宽度 */</span></div><div class="line">  <span class="attribute">white-space</span>: nowrap;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">animation</span>: typing <span class="number">4s</span> <span class="built_in">steps</span>(13);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想要效果逼真的话还需要加上闪烁的光标。加光标的话就很容易了,直接改 border-right-color 就可以了：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> caret &#123;</div><div class="line">	50% &#123; <span class="attribute">border-right-color</span>: inherit; &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> typing &#123;</div><div class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">width</span>: <span class="number">0</span> &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.typist</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">13em</span>; <span class="comment">/* 文本宽度 */</span></div><div class="line">  <span class="attribute">white-space</span>: nowrap;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">border-right</span>: .<span class="number">05em</span> solid transparent;</div><div class="line">  <span class="attribute">animation</span>: typing <span class="number">4s</span> <span class="built_in">steps</span>(13),</div><div class="line">						  caret <span class="number">1s</span> <span class="built_in">steps</span>(1) infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://7xtb3a.com2.z0.glb.clouddn.com/type-writer-true.gif" alt=""></p>
<p>至此动画已经很完善了。还剩最后一个问题：中文用 em 就能计算文字宽度，英文呢？其实在 css 中有许多不太常见的单位，比如：ch。在 MDN 文档中的解释：Represents the width, or more precisely the advance measure, of the glyph ‘0’ (zero, the Unicode character U+0030) in the element’s font. 意思是表示“0”字形的宽度。这个奇怪的单位在英文等宽字体中巧妙的解决了我们的问题，因为在等宽字体中，“0”字形的宽度和其他所有字形的宽度是一样的。</p>
<p>在定义英文字体的时候，我们需要找一个等宽字体，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">import</span> url(http://fonts.googleapis.com/css?family=Anonymous+Pro);</div><div class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: <span class="string">'Anonymous Pro'</span>, monospace; &#125;</div></pre></td></tr></table></figure>
<p>这样我们中文，英文都可以实现打字机效果啦！<br>github: <a href="https://github.com/KenHky/type-writer" target="_blank" rel="external">https://github.com/KenHky/type-writer</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css 揭秘这本书买了好久了，一直没有看完。趁着有空翻了一遍，有一个效果吸引到了我，就是类似终端的打字机效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtb3a.com2.z0.glb.clouddn.com/type-writer.gif&quot; alt=&quot;&quot;&gt;&lt;/
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.huangkaiyi.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端从入门到再次入门 - 异步</title>
    <link href="http://www.huangkaiyi.me/2016/11/01/%E5%89%8D%E7%AB%AF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%86%8D%E6%AC%A1%E5%85%A5%E9%97%A8%20-%20%E5%BC%82%E6%AD%A5/"/>
    <id>http://www.huangkaiyi.me/2016/11/01/前端从入门到再次入门 - 异步/</id>
    <published>2016-10-31T16:00:02.000Z</published>
    <updated>2016-11-01T09:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>异步是什么？那要从 javascript 这门语言说起。</p>
<p>javascript 诞生于1995年，作为当时浏览器专属的脚本语言，它被设计成了单线程。也就是说它在同一时间内只能做一件事。为什么是这样的呢？想象一下当 javascript 为多线程时，用户在一个节点添加内容，又在一个线程删除这个节点，浏览器该怎么去响应呢？</p>
<p>javascript 用单线程解决了浏览器里复杂的同步问题，但是单线程的话必然得引入一个概念，就是任务队列。在一个文明的社会里，需求多而物品少的话必然得排队，程序也是如此。当一个任务结束，下一个任务才会开始，看起来这样的规则很完美，但是有缺陷么？有的。比如说你去你最爱的面馆吃饭，结果发现门口排着长长的队，里面的座位却都是空的。原来这家面馆的流程是：顾客点单，小二下单 —— 顾客和小二大眼瞪小眼 —— 厨房把菜给小二，小二给顾客 —— 顾客端着菜来到餐桌吃饭 —— 结束。</p>
<p>这样的一个流程最要命的地方就在于顾客和小二大眼瞪小眼的阶段，时间都浪费在了这上面，所以排了很长的队大家都不满意。该怎么优化呢？</p>
<p>和面馆老板讨论后，给出了这样的优化方案：</p>
<p>顾客点单，小二下单 —— 小二给一个牌子给顾客，代表顾客的编号 —— 顾客坐在餐桌上开始玩手机聊天 —— 厨房把菜给小二，小二根据编号给顾客 —— 结束。</p>
<p>老板一听这样好呀，排队点人少了，小二的效率也高了，于是就请我吃了他们最好吃的牛肉面。</p>
<p>这就是异步，把耗时的操作在别的地方执行，执行完再把结果放回队列中。这样在这之间的时间可以做别的操作，而不是阻塞在这里。话说回来，javascript 语言是怎么实现异步的呢？就是回调函数。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数的英文名叫 callback，简单来说就是执行完一个任务后调用这个回调函数，这个回调函数能得到这个任务的结果。在 javascript 世界里到处都有回调函数的身影。最简单的就是 setTimeout 方法了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="string">'1000毫秒后出现我！'</span>), <span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p>上面的代码实际上的任务是等待1000毫秒，<code>() =&gt; alert(&#39;1000毫秒后出现我！&#39;)</code>就是回调函数。</p>
<p>回调函数很好用也很好理解，但是需要多个异步数据一起利用怎么办？一个异步任务的必要条件是另一个异步任务的结果又该怎么办？有人就开始写嵌套的 callback，俗称回调金字塔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</div><div class="line">    fun2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</div><div class="line">        fun3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</div><div class="line">            fun4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</div><div class="line">                <span class="comment">// …</span></div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种代码在 node 等高频异步处理里很常见。写着是挺好写的，等过了一天后你回头看自己的代码，写得都是些什么鬼？</p>
<p>至此我们就要踏上一场寻找前端异步处理最佳方案的道路。正如题目所说，你以为你入门了，其实前方还有一道又一道的门，俗称前端摩尔定律～</p>
<h2 id="EventProxy-与发布／订阅模式"><a href="#EventProxy-与发布／订阅模式" class="headerlink" title="EventProxy 与发布／订阅模式"></a>EventProxy 与发布／订阅模式</h2><p>正如这个库的作者<a href="https://github.com/JacksonTian" target="_blank" rel="external">朴灵</a>大大所说：</p>
<blockquote>
<p>这个世界上不存在所谓回调函数深度嵌套的问题。 —— <a href="http://weibo.com/shyvo" target="_blank" rel="external">Jackson Tian</a></p>
<p>世界上本没有嵌套回调，写得人多了，也便有了<code>}}}}}}}}}}}}</code>。 —— <a href="http://fengmk2.github.com" target="_blank" rel="external">fengmk2</a></p>
</blockquote>
<p><a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="external">EventProxy</a>就是为了解决嵌套的。</p>
<p>如果你要并发异步获取几个个地址的数据，并在获取所有数据后对这些数据进行处理的话，除了回调金字塔外最简单的写法是自己写一个计数器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> result = &#123;&#125;;</div><div class="line"></div><div class="line">$.get(<span class="string">'http://demo1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">	result.data1 = data;</div><div class="line">	count++;</div><div class="line">	handle();</div><div class="line">&#125;);</div><div class="line">$.get(<span class="string">'http://demo2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">	result.data2 = data;</div><div class="line">	count++;</div><div class="line">	handle();</div><div class="line">&#125;);</div><div class="line">$.get(<span class="string">'http://demo3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">	result.data3 = data;</div><div class="line">	count++;</div><div class="line">	handle();</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (count === <span class="number">3</span>) &#123;</div><div class="line">	  <span class="comment">// 后续操作result</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用了 EventProxy 以后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> eventproxy();</div><div class="line"></div><div class="line">proxy.all(<span class="string">'data1_event'</span>, <span class="string">'data2_event'</span>, <span class="string">'data3_event'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data1, data2, data3</span>) </span>&#123;</div><div class="line">  <span class="comment">// 后续操作result</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">$.get(<span class="string">'http://demo1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  proxy.emit(<span class="string">'data1_event'</span>, data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$.get(<span class="string">'http://demo2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  proxy.emit(<span class="string">'data2_event'</span>, data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$.get(<span class="string">'http://demo3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  proxy.emit(<span class="string">'data3_event'</span>, data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是一个典型的事件发布／订阅模式。我们抛开代码，先来聊聊什么是发布／订阅模式。</p>
<p>发布／订阅模式，又叫做观察者模式。发布／订阅模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。</p>
<p>简单的说，你最爱的面馆的厨师回乡娶媳妇去了，新厨师做的牛肉面不合你口味，于是你每天都打电话给餐馆问老厨师回来了么。老板再也受不了了，每天都接到类似的电话要疯了，问我怎么处理。我说简单啊，把每个想吃老厨师做牛肉面的人的电话记下来，和他们说老厨师来了就给他们发短信。于是老板的电话终于安静了。</p>
<p>上面这个弱智的例子就是发布／订阅模式，我们生活中经常会遇到。老板是发布者，顾客是订阅者，顾客订阅了老厨师回来的信息，当老厨师回来后老板把这个消息发布给顾客。发布／订阅模式有什么好处呢？它能够解耦逻辑，发布者不用关心订阅者具体的业务逻辑，也不用关心有多少订阅者，就能把消息传递给订阅者。订阅者也不用每次询问发布者有没有消息，但也会在第一时间得到他想要的消息。</p>
<p>回到 EventProxy，上面例子中<code>proxy.emit(&#39;data1_event&#39;, data)</code>就是发布者，<code>proxy.all</code>就是订阅者，但是 EventProxy 的 all API 可以同时订阅多个消息，并在获得所有消息后进行处理，这是对普通发布／订阅模式的扩充。</p>
<p>EventProxy 具体的实现原理来自 Backbone 的事件模块，感兴趣的可以去它的<a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="external">github</a>里查看。</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>promise 是什么？promise 的中文意思是承诺。</p>
<p>记得我第一次接触 promise 是在我第一个 angular 项目中，当时项目的代码里很多<code>promise.then().then()</code>，并不知道是什么意思，觉得好高端啊。当时的 leader 和我说，promise 很简单，就是先给你一个承诺，完成以后再进行下一步处理。它传递的始终是一个 promise 对象。</p>
<p>那时候我天真的以为 promise 只有 angular 才有，后来才发现 angular 里的 $q 只是其中一种 promise 实现。AngularJS 的整个代码库很大程度上依赖于 Promise，包括框架以及你用它编写的应用代码。</p>
<p>说回正题。有很多第三方库实现了 promise，像 when，angular 用的 $q 等。他们遵循同一规范：<a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+</a>。如今在 ECMAScript 2015 规范中 javascript 支持了原生的 promise（当然如果想要兼容性的话请用 babel）。</p>
<p>所谓 Promise，就是有一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。一个 promise 可能有三种状态：未完成、已完成、已失败。一个 promise 的状态只可能从未完成转到已完成或者已失败，不能逆向转换，同时已完成和已失败不能相互转换。同时需要注意的是他们之间传递的都是 promise 对象。</p>
<p>举个栗子：你在面馆点了餐，小二给了你一个餐牌。这个餐牌对你来说没有什么用，你既不能吃又不能卖了换钱，只是代表你付了钱点了餐，这就是一个未完成的状态。厨房做好以后小二拿着牛肉面换你的餐牌，你得到了你想吃的牛肉面，这就是已完成的状态。厨房的牛肉卖完了，小二跑来和你道歉，让你换一碗面或者退你钱，这就是已失败状态和失败后的处理。已失败并不能直接转换成已完成，你想换一碗面还是要走一遍 promise 流程，这就是已完成和已失败不能相互转换。</p>
<p>知道了 promise 的理论后，我们来看看原生的 promise:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">    <span class="comment">// 小二承诺给你一碗牛肉面</span></div><div class="line">    <span class="keyword">if</span> (success)&#123;</div><div class="line">	    <span class="comment">// resolve牛肉面给你</span></div><div class="line">      <span class="keyword">return</span> resolve(data);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	    <span class="comment">// 厨房牛肉卖完了，reject了一个错误给你</span></div><div class="line">      <span class="keyword">return</span> reject(data);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="comment">// 成功啦，开吃</span></div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="comment">// 失败啦，我要退钱！！</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这里的变量 promise 是 Promise 这个对象的实例。逻辑处理完以后如果没有错误，你就能在 then 中的第一个回调函数得到牛肉面，如果有错误则会在 then 中第二个回调函数中进行错误处理。</p>
<p>promise 还提供一个<code>Promise.all()</code>的方法，效果类似于 EventProxy 的 all，不过它返回的是一个 promise 对象。当所有 promise 对象都成功以后才会进入已完成状态，要是有其中一个 promise 进入已失败状态，<code>Promise.all</code>也会进入已失败状态。具体可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all</a></p>
<p>promise 最大的好处就是通过链式调用解决了回调的深层嵌套的问题，看起来很优雅，也很容易理解和使用。但你以为这就是 javascript 异步编程的全部了？</p>
<h2 id="Generator与TJ的co"><a href="#Generator与TJ的co" class="headerlink" title="Generator与TJ的co"></a>Generator与TJ的co</h2><p>Generator 中文含义是生成器。在 javascript 世界里，函数是不存在被执行之后还能暂停的情况，只有“被调用”和“没有被调用”的状态。当函数能够暂停的话会发生什么？</p>
<p>Generator就是那个能够暂停的函数，它的本质可以理解为一种特殊的数据结构。和普通函数相比，它多了一个<code>*</code>号，<code>*</code>号出现在关键字 function 和函数名之间，如果是匿名函数，则出现在 function 和参数列表的起始括号之间。</p>
<p>那么它是如何实现暂停的呢？通过函数里的 yield 关键字和 next 方法。我们先看一个例子简单的了解一下写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">a, b</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> sum = a + b;</div><div class="line">	<span class="keyword">yield</span> sum;</div><div class="line">	<span class="keyword">var</span> subtract = a - b;</div><div class="line">	<span class="keyword">yield</span> subtract;</div><div class="line">	<span class="keyword">return</span> a</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> generator = g(<span class="number">2</span>, <span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: 3, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: 2, done: true &#125;</span></div></pre></td></tr></table></figure>
<p>我们一步一步的来解读下上面的例子：</p>
<p>1.首先创建了一个 Generator 函数，命名为 g。</p>
<p>2.实例化这个函数，命名为 generator。这时的 generator 是一个 Generator 对象，他有一个 next 方法。当你没有调用 next 的时候，Generator 函数内部执行到第一个 yield 前就暂停到这里不再执行了。</p>
<p>3.当我们第一次调用<code>generator.next()</code>时，会返回第一个 yield 后面的对象，不过返回的对象有两个属性，一个是 value，即它的本体；一个是 done，代表该 Generator 函数是否结束。所以第一次调用 next 返回了<code>{ value: 3, done: false }</code>。（注意：如果 yield 后面接的不是对象例如是字符串的话，next 会直接返回字符串）。</p>
<p>4.第二次调用如上，第三次调用的时候 Generator 函数已经没有 yield 关键字了，所以返回的 done 为 true。</p>
<p>需要注意的是，<code>.next()</code>调用只会执行 yield 后面的对象，下一次调用时才会执行完yield 所在行。我们可以通过<code>generator.next()</code>赋值来传递参数给函数。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params">a, b</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> sum = <span class="keyword">yield</span> a + b;</div><div class="line">	<span class="built_in">console</span>.log(sum);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> generator = g(<span class="number">2</span>, <span class="number">1</span>);</div><div class="line">generator.next();</div><div class="line">generator.next(<span class="string">"hello"</span>); <span class="comment">// hello</span></div></pre></td></tr></table></figure>
<p>这个例子和前面的很像，只是我们把 yield 加在了变量 sum 后面。当第一次执行<code>generator.next()</code>时，<code>generator.next()</code>和前面的例子一样返回<code>{ value: 3, done: false }</code>。这时还没有执行 sum 的赋值操作。再一次执行<code>generator.next(&quot;hello&quot;)</code>后，<code>generator.next(&quot;hello”)</code>返回<code>{ value: undefined, done: true }</code>，因为后面没有 yield 了。和前面的例子不一样的是我们传了一个 hello 给函数，这时会进行 sum 的赋值，即<code>var sum = “hello”</code>。所以函数运行到<code>console.log(sum)</code>的时候 sum 就是<code>hello</code>了。</p>
<p>通过这种方式动态的传递数据，使得代码逻辑更灵活，同时才有能力达到我们的目的：异步优化。异步怎么用 Generator 呢？首先能想到的就是在异步处理后把得到的值通过<code>generator.next(data)</code>传递给函数体。下面我结合 promise 用 Generator 来实现异步：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">resolve</span>)</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;); <span class="comment">// 创建一个 promise 模拟异步请求</span></div><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> hello = <span class="keyword">yield</span> promise;</div><div class="line">    <span class="built_in">console</span>.log(hello);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> generator = g();</div><div class="line"><span class="keyword">var</span> result = generator.next();</div><div class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    generator.next(data);</div><div class="line">&#125;); <span class="comment">// 打印出"hello"</span></div></pre></td></tr></table></figure>
<p>这个例子我先创建了一个 promise 来模拟异步请求，然后在 Generator 函数体内 yield 了这个 promise。第一次执行<code>generator.next()</code>会返回一个 value 为 promise 对象，所以我们用 promise 的 then 里能得到异步返回的值，即例子里的”hello”。然后在 then 方法里再调用<code>generator.next(data)</code>把异步的返回值返回给 Generator 函数体。最后会打印出<code>hello</code>，结束这次异步处理。</p>
<p>虽然现在的异步有点像同步了，但是大家有没有觉得例子后面手动调用 generator.next() 很繁琐很丑么？不是很丑是丑屎了～</p>
<p>能不能装逼的方式简单一点呢？能。下面我要介绍一下著名程序员TJ大神写的co库。co库是一个基于 Generator 的函数库，主要目的是自动化调用<code>.next()</code>方法。具体的写法是在 co 函数里包裹一个 Generator 函数。</p>
<p>最早在 co 的 Generator 函数内只能 yield 一个 trunk 函数，1.1.0以后加入了 promise 支持，后续慢慢开始支持 generators, generator functions, object, array。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> hello = <span class="keyword">yield</span> promise</div><div class="line">	<span class="built_in">console</span>.log(hello)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>省去了手动调用<code>.next()</code>方法，写法更清晰了，就这么简单～</p>
<p>因为4.0.0版本以后 co 函数返回一个 promise 对象，你可以添加回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> hello = <span class="keyword">yield</span> promise</div><div class="line">	<span class="built_in">console</span>.log(hello)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"world!"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在早期版本（1.4.0）co 提供了一个<code>join</code>方法来实现并发异步，现在可以直接 yield 一个数组或者字符串来实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// array</span></div><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</div><div class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</div><div class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</div><div class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</div><div class="line">  ];</div><div class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// =&gt; [1, 2, 3]</span></div><div class="line">&#125;).catch(onerror);</div><div class="line"></div><div class="line"><span class="comment">// object</span></div><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</div><div class="line">    <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</div><div class="line">    <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</div><div class="line">  &#125;;</div><div class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// =&gt; &#123; 1: 1, 2: 2 &#125;</span></div><div class="line">&#125;).catch(onerror);</div></pre></td></tr></table></figure>
<p>co 还允许你在函数体里用<code>try/catch</code>，这样很方便的抛出错误。co 的源码很少，感兴趣的童鞋可以去看一看<a href="https://github.com/tj/co/blob/master/index.js" target="_blank" rel="external">https://github.com/tj/co/blob/master/index.js</a>。</p>
<p>需要注意的是，Generator 是属于 ES6 的方法。不过如今 node 都发布到7.0版本了，是能够直接支持的。前端请用 babel。另外如果只是尝试一下的话可以打开 chrome 控制台。因为 chrome 是v8内核，可以直接使用 Generator 和 promise 的。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>前面我们谈到了 co，这么好用的异步方案有没有官方的实现呢？恭喜你，在这个 javascript 极速进化的时代官方是有类似的方案的，这就是 async/await。</p>
<p>这个出现在 ES7 中的方案其实就是 Generator 的语法糖。我们看一下下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">const</span> testAsync = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> hello = <span class="keyword">await</span> promise;</div><div class="line">  <span class="built_in">console</span>.log(hello);</div><div class="line">&#125;;</div><div class="line">testAsync();</div></pre></td></tr></table></figure>
<p>是不是和 co 一毛一样！唯一的区别就是把<code>*</code>换成了<code>async</code>，把 yield 换成了<code>await</code>，另外能像 co 一样执行类似 Generator 的<code>.next()</code>方法，也不用包裹在co函数里了。是不是很棒！</p>
<p>如果我们希望多个异步并发执行，类似于在 EventProxy 里那样，可以结合<code>Promise.all</code>来实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"hello"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"world!"</span>),<span class="number">1000</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">const</span> testAsync = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([promise1,promise2]);</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;;</div><div class="line">testAsync();</div></pre></td></tr></table></figure>
<p>相比于 Generator，async/await 在语义上更清晰，<code>async</code>的意思是异步，<code>await</code>的意思是等待。async/await 本身就是为处理异步而生，而 Generator 并不是专门处理异步的。<code>await</code>后面除了可以跟 promise 对象，还可以用原始类型的值（当然这样的话就和同步操作没有区别了）。</p>
<p>这么酷的语法要使用的话在 node 端7.0版本已经原生支持，在前端可以通过 babel 编译来实现。当然万能的 chrome 控制台也可以直接使用的～</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>在宁 js 大会上我第一次听说 Rx.js（原谅我孤陋寡闻），这也是很好的异步处理方案。等以后再专门写一篇 Rx.js 的入门。前端的异步解决方案这么多，说到底还是因为人们对于 callback 的恐惧。这些解决方案有个共同的特点，就是越来越像同步的代码，这样的好处就是代码更易读了，思维不用随着 callback 跳来跳去了。最后说一句，本文只是入门，没有涉及具体的实现，要想学好它们的话还是需要深入代码，了解它们背后的思想。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/alsotang/node-lessons/tree/master/lesson4" target="_blank" rel="external">https://github.com/alsotang/node-lessons/tree/master/lesson4</a></p>
<p><a href="http://www.infoq.com/cn/articles/generator-and-asynchronous-programming" target="_blank" rel="external">http://www.infoq.com/cn/articles/generator-and-asynchronous-programming</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异步是什么？那要从 javascript 这门语言说起。&lt;/p&gt;
&lt;p&gt;javascript 诞生于1995年，作为当时浏览器专属的脚本语言，它被设计成了单线程。也就是说它在同一时间内只能做一件事。为什么是这样的呢？想象一下当 javascript 为多线程时，用户在一个节
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.huangkaiyi.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>动手写一个react native的date picker组件</title>
    <link href="http://www.huangkaiyi.me/2016/07/24/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAreact%20native%E7%9A%84date%20picker%E7%BB%84%E4%BB%B6/"/>
    <id>http://www.huangkaiyi.me/2016/07/24/动手写一个react native的date picker组件/</id>
    <published>2016-07-24T04:25:02.000Z</published>
    <updated>2016-07-24T05:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博文我写了一个react native的menu button组件，享受到了组件化开发的乐趣。在写app的过程中需要很多的组件，其中选择日期的组件算是很常用的。一开始我们在网上找了一些现成的组件，但是由于react native不像css一样有z-index属性，所以那些组件在使用中经常出现前后的位置不对的问题。</p>
<p>在我的想法里，只要是弹出的东西，而且不会弹出多个的，都可以用原生的modal实现。modal一直都脱离了文档流在最外面，可以很方便做这些组件。是的，我又来造轮子了。</p>
<p>除了modal，还有那些原生组件可以加速我们的开发呢？答案是iOS的picker组件。这样一个iOS风格的组件不支持安卓挺遗憾的，但是还好万能的社区有人实现了安卓端的相同api的picker。<a href="https://github.com/beefe/react-native-picker-android" target="_blank" rel="external">react-native-picker-android</a>。这样我们就不会为安卓端端适配烦恼了。</p>
<p>我的想法是点击日期弹出一个modal，modal里有使用三个picker分别对应年月日。看起来挺简单，实现的难点在于怎么使年月日能够联动。可以每次选择年月都算出有多少日。我选择了一个笨方法，一个空间换时间的方法。就是遍历出1950年到2050年所有的年月日。实际上数据不会大到夸张的程度，而且每次组件选完了这些数据都会清除掉，不会有什么性能问题。我的实现如下：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">createDateData ()&#123;</div><div class="line">    <span class="keyword">let</span> date = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1950</span>;i&lt;<span class="number">2050</span>;i++)&#123;</div><div class="line">        <span class="keyword">let</span> month = &#123;&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;<span class="number">13</span>;j++)&#123;</div><div class="line">            <span class="keyword">let</span> day = [];</div><div class="line">            <span class="keyword">if</span>(j === <span class="number">2</span>)&#123;</div><div class="line">                <span class="keyword">if</span> (((i % <span class="number">4</span>)==<span class="number">0</span>) &amp;&amp; ((i % <span class="number">100</span>)!=<span class="number">0</span>) || ((i % <span class="number">400</span>)==<span class="number">0</span>))&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">1</span>;k&lt;<span class="number">30</span>;k++)&#123;</div><div class="line">                        day.push(k+<span class="string">'日'</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">1</span>;k&lt;<span class="number">29</span>;k++)&#123;</div><div class="line">                        day.push(k+<span class="string">'日'</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j <span class="keyword">in</span> &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">3</span>:<span class="number">1</span>, <span class="number">5</span>:<span class="number">1</span>, <span class="number">7</span>:<span class="number">1</span>, <span class="number">8</span>:<span class="number">1</span>, <span class="number">10</span>:<span class="number">1</span>, <span class="number">12</span>:<span class="number">1</span>&#125;)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">1</span>;k&lt;<span class="number">32</span>;k++)&#123;</div><div class="line">                    day.push(k+<span class="string">'日'</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">1</span>;k&lt;<span class="number">31</span>;k++)&#123;</div><div class="line">                    day.push(k+<span class="string">'日'</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            month[j+<span class="string">'月'</span>] = day;</div><div class="line">        &#125;</div><div class="line">        date[i+<span class="string">'年'</span>] = month;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> date;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>数据有了剩下的事情就简单了，每次选择年或月数据都换成相应的年月。当日期选择后再换年月有种情况会新选的月份没有这个日期。比如你选择了1月31日，换成2月没有31日，我们要加一个判断把日的选择换成2月里的最大日期29号或者28号。</p>
<p><img src="http://7xtb3a.com2.z0.glb.clouddn.com/datepicker-ios.gif" alt=""></p>
<p>最后实现的代码可以查看：<a href="https://github.com/KenHky/react-native-modal-date-picker" target="_blank" rel="external">https://github.com/KenHky/react-native-modal-date-picker</a>。</p>
<p>我暴露了这些api：</p>
<p>selectData: 选择的值，通过onSelect回调修改，格式为“YYYY-MM-DD”。</p>
<p>onSelect： 回调函数，参数为修改后的data值。</p>
<p>formater： 显示的格式，默认为“YYYY-MM-DD”，可参考<a href="http://http://momentjs.com/" target="_blank" rel="external">moment</a>修改。</p>
<p>cancleText： 取消的文本，默认为“取消”。</p>
<p>finishText： 确定的文本，默认为“确定”。</p>
<p>title： 组件标题，默认为“请选择日期”。</p>
<p>modalColor： modal层的颜色，默认为“rgba(0,0,0,0.4)”。</p>
<p>pickerColor： 组件的颜色，默认为“rgba(255,255,255,0.8)”。</p>
<p>buttonColor： 确定和取消按钮的颜色，默认为“#FE751D”。</p>
<p>pickerHeight： 组件的高度，默认为400。</p>
<p>keepShowModal： 点击组件外的modal层是否不关闭组件，默认关闭组件。值为true或false。</p>
<p>使用的话像这样：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> Picker <span class="keyword">from</span> <span class="string">'react-native-modal-date-picker'</span></div><div class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwesomeProject</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">value</span>: moment(<span class="keyword">new</span> <span class="built_in">Date</span>).format(<span class="string">'YYYY-MM-DD'</span>)</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  onSelect (value) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:value&#125;)   </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;marginTop:40&#125;&#125;</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">Picker</span> <span class="attr">selectData</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onSelect</span>=<span class="string">&#123;this.onSelect.bind(this)&#125;</span> <span class="attr">formater</span>=<span class="string">"YYYY-MM-DD hh:mm:ss"</span> <span class="attr">cancleText</span>=<span class="string">"cancle"</span> <span class="attr">finishText</span>=<span class="string">"finish"</span> <span class="attr">title</span>=<span class="string">"title"</span> <span class="attr">modalColor</span>=<span class="string">"#000"</span> <span class="attr">keepShowModal</span>=<span class="string">&#123;true&#125;</span> <span class="attr">pickerHeight</span>=<span class="string">&#123;400&#125;</span> <span class="attr">pickerColor</span>=<span class="string">"#fff"</span> <span class="attr">buttonColor</span>=<span class="string">"#000"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent('AwesomeProject', () =&gt; AwesomeProject);</div></pre></td></tr></table></figure>
</code></pre><p>一个简单的modal picker就完成了。目前只能选择日期，以后有空会加上更多的功能，比如时间选择之类。写react native组件的过程是很有趣的，欢迎大家也动手实践。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博文我写了一个react native的menu button组件，享受到了组件化开发的乐趣。在写app的过程中需要很多的组件，其中选择日期的组件算是很常用的。一开始我们在网上找了一些现成的组件，但是由于react native不像css一样有z-index属性，所以
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.huangkaiyi.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的react native menu button组件</title>
    <link href="http://www.huangkaiyi.me/2016/07/24/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84react%20native%20menu%20button%E7%BB%84%E4%BB%B6/"/>
    <id>http://www.huangkaiyi.me/2016/07/24/一个简单的react native menu button组件/</id>
    <published>2016-07-23T16:07:52.000Z</published>
    <updated>2016-07-24T03:26:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近我司有一个内部轻app由我们前端开发，技术选型不假思索的选择了react-native。谁叫react-native这么火呢。如今此app已经开始使用了，开发过程中有一个又一个的坑,下次专门写篇博文聊一聊踩坑。</p>
<p>我们有一个需求是在title的右边有一个button，点击弹出一个menu。网上搜一下有人实现了这样的组件（这里推荐一个寻找react-native或者react组件的网站：<a href="https://js.coach/" target="_blank" rel="external">js.coach</a>），叫<a href="https://github.com/jaysoo/react-native-menu" target="_blank" rel="external">react-native-menu</a>。试用了一下，功能是可以了，但是打开menu后想点击别的地方关闭menu比较麻烦，要调用自身的方法。深入它的代码想看看是怎么实现的，经过断点发现它只要打开menu就有一个方法每隔16毫秒setState一次，一直循环。这对性能有很大的影响。</p>
<p>仔细想一下，其实实现这样一个功能并不难，干脆自己造轮子好了。首先要想的是怎么才能方便的点击外部方便的关闭menu。这种需要弹出的东西而且只会弹出一个的完全可以用原生的modal实现。我把这个组件分为一个个小组件拼接成这个menu button。</p>
<p>先写了一个按钮命名为MenuSwitch，接收两个props，一个是点击事件onPress，一个是按钮里的样式content，默认content我写成这样 :</p>
<pre><code><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;&#123; fontSize: 20,textAlign:"right" &#125;&#125;&gt;&amp;#8942;&lt;/Text&gt;</div></pre></td></tr></table></figure>
</code></pre><p>点击这个button会改变一个state的值用来控制显示或不显示menu。menu写在一个modal里面，modal独立为一个组件叫MenuModal，点击的时候控制关闭modal。modal上面有一个menu独立为MenuOptions组件，点击的时候相应相应的事件。这时好奇的宝宝可能会问了，react-native是不是像web一样有一个冒泡捕获的过程。实际上react-native的onPress事件如果有多层次的话只会执行嵌套最深的那次，不会冒泡到外面的onPress事件的。所以我们点击menu的时候不会调用modal上的onPress方法。</p>
<p>Menu显示的条数由组件外部传入一个menuGroup控制，格式为：[{key:num or str,value:num or str,text:str,hide:Boolean}]。value为点击发生后传的值，text为显示的字符串，hide为true时隐藏该条数据，默认为false。</p>
<p>写到这里我们的menu组件就差不多完成了，处理下细节，组件内的render如下：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">render () &#123;</div><div class="line">    <span class="keyword">const</span> &#123;openMenu,menuName,layout&#125; = <span class="keyword">this</span>.state</div><div class="line">    <span class="keyword">const</span> &#123;buttonStyle,menuGroup,optionsStyle,button&#125; = <span class="keyword">this</span>.props</div><div class="line">    <span class="keyword">const</span> <span class="built_in">window</span> = Dimensions.get(<span class="string">'window'</span>)</div><div class="line">    <span class="keyword">const</span> optionsStyles = &#123;...optionsStyle,<span class="attr">top</span>:layout.y,<span class="attr">right</span>:(<span class="built_in">window</span>.width-layout.x-layout.width)&#125;</div><div class="line">    <span class="keyword">const</span> buttonContent = button?button:(<span class="xml"><span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> <span class="attr">20</span>,<span class="attr">textAlign:</span>"<span class="attr">right</span>" &#125;&#125;&gt;</span>&amp;#8942;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>)</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;buttonStyle&#125;</span> <span class="attr">onLayout</span>=<span class="string">&#123;this.onLayout&#125;</span>&gt;</span></span></div><div class="line">            <span class="tag">&lt;<span class="name">MenuSwitch</span> <span class="attr">content</span>=<span class="string">&#123;buttonContent&#125;</span> <span class="attr">onPress</span>=<span class="string">&#123;this.toggleMenu&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">MenuSwitch</span>&gt;</span></div><div class="line">            &#123;</div><div class="line">                openMenu==menuName?(</div><div class="line">                    <span class="tag">&lt;<span class="name">MenuModal</span> <span class="attr">onPress</span>=<span class="string">&#123;this.closeMenu&#125;</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">MenuOptions</span> <span class="attr">style</span>=<span class="string">&#123;optionsStyles&#125;</span>&gt;</span></div><div class="line">                                &#123;</div><div class="line">                                    menuGroup.map((menu)=&gt; &#123;</div><div class="line">                                        if (!menu.hide) &#123;</div><div class="line">                                            return (</div><div class="line">                                                <span class="tag">&lt;<span class="name">MenuOption</span> <span class="attr">key</span>=<span class="string">&#123;menu.key&#125;</span> <span class="attr">onPress</span>=<span class="string">&#123;this.onPress.bind(null,menu.value)&#125;</span>&gt;</span></div><div class="line">                                                    <span class="tag">&lt;<span class="name">Text</span>&gt;</span>&#123;menu.text&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div><div class="line">                                                <span class="tag">&lt;/<span class="name">MenuOption</span>&gt;</span></div><div class="line">                                            )</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;)</div><div class="line">                                &#125;</div><div class="line">                            <span class="tag">&lt;/<span class="name">MenuOptions</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">MenuModal</span>&gt;</span></div><div class="line">                ):null</div><div class="line">            &#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line"></div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>最后实现的效果如下：</p>
<p><img src="http://7xtb3a.com2.z0.glb.clouddn.com/menubutton-ios.gif" alt=""><br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/menubutton-android.gif" alt=""></p>
<p>完整的代码可以看这里<a href="https://github.com/KenHky/react-native-menu-button" target="_blank" rel="external">https://github.com/KenHky/react-native-menu-button</a>。</p>
<p>组件我们写完了，怎么使用呢？为们新建一个AwesomeProject,像如下使用：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> MenuButton <span class="keyword">from</span> <span class="string">'react-native-menu-button'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AwesomeProject</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  componentDidMount() &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">selectData</span>:<span class="string">""</span></div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  _handleOnSelect (value) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">selectData</span>:value&#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    menuGroup= [&#123;<span class="attr">key</span>:<span class="string">"0"</span>,<span class="attr">value</span>:<span class="string">"menu1"</span>,<span class="attr">text</span>:<span class="string">"menu1"</span>&#125;,&#123;<span class="attr">key</span>:<span class="string">"1"</span>,<span class="attr">value</span>:<span class="string">"menu2"</span>,<span class="attr">text</span>:<span class="string">"menu2"</span>&#125;,&#123;<span class="attr">key</span>:<span class="string">"2"</span>,<span class="attr">value</span>:<span class="string">"菜单3"</span>,<span class="attr">text</span>:<span class="string">"菜单3"</span>&#125;,&#123;<span class="attr">key</span>:<span class="string">"3"</span>,<span class="attr">value</span>:<span class="string">"菜单4"</span>,<span class="attr">text</span>:<span class="string">"菜单4"</span>&#125;]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.top&#125;</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">MenuButton</span>  <span class="attr">buttonStyle</span>=<span class="string">&#123;[styles.rightButton]&#125;</span> <span class="attr">menuGroup</span>=<span class="string">&#123;menuGroup&#125;</span></span></div><div class="line">            <span class="attr">onSelect</span>=<span class="string">&#123;this._handleOnSelect.bind(this)&#125;/</span>&gt;</div><div class="line">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.text&#125;</span>&gt;</span>&#123;`select $&#123;this.state.selectData&#125;`&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  top:&#123;</div><div class="line">    backgroundColor: '#FFFFFF',</div><div class="line">    paddingTop: 20,</div><div class="line">    top: 0,</div><div class="line">    height: 64,</div><div class="line">    right: 0,</div><div class="line">    left: 0,</div><div class="line">    borderBottomWidth: 0.5,</div><div class="line">    borderBottomColor: '#828287',</div><div class="line">    position: 'relative',</div><div class="line">  &#125;,</div><div class="line">  text:&#123;</div><div class="line">    marginTop:20,</div><div class="line">  &#125;,</div><div class="line">  rightButton: &#123;</div><div class="line">    width: 100,</div><div class="line">    height: 37,</div><div class="line">    position: 'absolute',</div><div class="line">    bottom: 8,</div><div class="line">    right: 2,</div><div class="line">    padding: 8</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">AppRegistry.registerComponent('AwesomeProject', () =&gt; AwesomeProject);</div></pre></td></tr></table></figure>
</code></pre><p>这个组件还有很多不足，如果有什么好的意见建议欢迎联系我哦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我司有一个内部轻app由我们前端开发，技术选型不假思索的选择了react-native。谁叫react-native这么火呢。如今此app已经开始使用了，开发过程中有一个又一个的坑,下次专门写篇博文聊一聊踩坑。&lt;/p&gt;
&lt;p&gt;我们有一个需求是在title的右边有一个bu
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.huangkaiyi.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>几种方法export你的模块(兼容AMD, CommonJS, Node.js等)</title>
    <link href="http://www.huangkaiyi.me/2016/05/05/%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95export%E4%BD%A0%E7%9A%84%E6%A8%A1%E5%9D%97-%E5%85%BC%E5%AE%B9AMD-CommonJS-Node-js%E7%AD%89/"/>
    <id>http://www.huangkaiyi.me/2016/05/05/几种方法export你的模块-兼容AMD-CommonJS-Node-js等/</id>
    <published>2016-05-05T13:12:52.000Z</published>
    <updated>2016-07-24T03:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>模块化是前端这几年提的比较多的技术点，前端代码不像后端代码，Javascript不是一种模块化编程语言，直到es6才开始支持class和module。为了让大家能方便的加载各种模块，出现了一些Javascript的模板规范，如 CommonJS 和 AMD 。</p>
<p>我们一般遇到一些通用的可以模块出来的代码，可以根据我们所用的规范来export你的代码。但是想要多种规范和没有规范直接使用都支持呢？像jquery等框架一样的通用代码该怎么做呢？</p>
<p>通过查看jQuery的源码，可以整理出如下：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> global, factory </span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span> ) &#123;</div><div class="line">        <span class="comment">// For CommonJS and CommonJS-like environments where a proper `window`</span></div><div class="line">        <span class="comment">// is present, execute the factory and get jQuery.</span></div><div class="line">        <span class="comment">// For environments that do not have a `window` with a `document`</span></div><div class="line">        <span class="comment">// (such as Node.js), expose a factory as module.exports.</span></div><div class="line">        <span class="comment">// This accentuates the need for the creation of a real `window`.</span></div><div class="line">        <span class="comment">// e.g. var jQuery = require("jquery")(window);</span></div><div class="line">        <span class="comment">// See ticket #14549 for more info.</span></div><div class="line">        <span class="built_in">module</span>.exports = global.document ?</div><div class="line">            factory( global, <span class="literal">true</span> ) :</div><div class="line">            <span class="function"><span class="keyword">function</span>(<span class="params"> w </span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> ( !w.document ) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"jQuery requires a window with a document"</span> );</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> factory( w );</div><div class="line">            &#125;;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        factory( global );</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// Pass this if window is not defined yet</span></div><div class="line">&#125;(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> window, noGlobal </span>) </span>&#123;</div><div class="line">  <span class="comment">// jQuery code</span></div><div class="line">&#125;));</div></pre></td></tr></table></figure>
</code></pre><p>可以看到 typeof window !== “undefined” ? window : this 用于判断当前执行环境是否支持window类型，是的话返回window，否则返回this。如果当前环境不支持window.document属性，throw一个Error说这环境不适用jQuery，但依旧返回jQuery的功能函数。实际上我们想模块化的代码很多时候不像jQuery一样大而全并且依赖window.document属性，有没有更好的写法呢？</p>
<p>有一个很流行的时间处理函数库叫moment.js，它兼容我们想要的多种方式，让我们看下它是怎么实现的：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">global, factory</span>) </span>&#123;</div><div class="line">    <span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> ? <span class="built_in">module</span>.exports = factory() :</div><div class="line">    <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define(factory) :</div><div class="line">    global.moment = factory()</div><div class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="string">'use strict'</span>;</div><div class="line">    <span class="comment">//return moment</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><p>和jQuery很像嘛，这样看起来就简单多了，就是判断一下是否支持commonJs，然后判断是否支持AMD，否则直接挂在global上。</p>
<p>其实写法不止一种，但是原理都是大同小异。再分享一下cookie.js的写法：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">undefined</span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> Cookies = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//cookie code</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// cookie code</span></div><div class="line">    Cookies._document = <span class="built_in">document</span>;</div><div class="line"></div><div class="line">        <span class="comment">// AMD support</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</div><div class="line">        define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> Cookies; &#125;);</div><div class="line">    <span class="comment">// CommonJS and Node.js module support.</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="comment">// Support Node.js specific `module.exports` (which can be a function)</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</div><div class="line">            exports = <span class="built_in">module</span>.exports = Cookies;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)</span></div><div class="line">        exports.Cookies = Cookies;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">window</span>.Cookies = Cookies;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块化是前端这几年提的比较多的技术点，前端代码不像后端代码，Javascript不是一种模块化编程语言，直到es6才开始支持class和module。为了让大家能方便的加载各种模块，出现了一些Javascript的模板规范，如 CommonJS 和 AMD 。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.huangkaiyi.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript判断两个多边形相交</title>
    <link href="http://www.huangkaiyi.me/2016/04/26/javascript%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9B%B8%E4%BA%A4/"/>
    <id>http://www.huangkaiyi.me/2016/04/26/javascript判断两个多边形相交/</id>
    <published>2016-04-26T14:57:00.000Z</published>
    <updated>2016-07-23T03:52:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在业务中有个需求是用高德api绘制多个多边形，且多边形不能有重合的地方。高德并没有提供这种api，所以自己尝试着实现了一个算法。</p>
<p>判断两个多边形是否相交，首先从业务需求来想，最多的情况肯定是两个多边形不相交，从这个角度想的话，有什么情况下两个多边形一定不相交呢？打个比方：有一本书，书的平面下方放着你的手机，你的书的最下一的个点是不是比你手机最上一个点还要高？这种情况很容易判断，所以我们先写算法把他排除。<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/book.png" alt=""></p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//极值判断两多边形不相交</span></div><div class="line"><span class="keyword">var</span> shape1= [&#123;<span class="string">"x"</span>:<span class="number">1</span>,<span class="string">"y"</span>:<span class="number">3</span>&#125;,&#123;<span class="string">"x"</span>:<span class="number">3</span>,<span class="string">"y"</span>:<span class="number">3</span>&#125;,&#123;<span class="string">"x"</span>:<span class="number">3</span>,<span class="string">"y"</span>:<span class="number">2</span>&#125;,&#123;<span class="string">"x"</span>:<span class="number">1</span>,<span class="string">"y"</span>:<span class="number">2</span>&#125;];</div><div class="line"><span class="keyword">var</span> shape2= [&#123;<span class="string">"x"</span>:<span class="number">1</span>,<span class="string">"y"</span>:<span class="number">1</span>&#125;,&#123;<span class="string">"lat"</span>:<span class="number">2</span>,<span class="string">"lng"</span>:<span class="number">2</span>&#125;,&#123;<span class="string">"lat"</span>:<span class="number">3</span>,<span class="string">"lng"</span>:<span class="number">1</span>&#125;];</div><div class="line"><span class="keyword">var</span> checkTwoPolygonByDirection = <span class="function"><span class="keyword">function</span> (<span class="params">polygon1,polygon2</span>) </span>&#123;</div><div class="line">    <span class="comment">//得到一个多边形的极值数组［左，上，右，下］</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDirection</span>(<span class="params">shape</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> shapeEastAndWest = [],shapeSourceAndNorth = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shape.length; i++) &#123;</div><div class="line">            shapeEastAndWest.push(shape[i].x);</div><div class="line">            shapeSourceAndNorth.push(shape[i].y);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span>[<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,shapeEastAndWest),<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,shapeSourceAndNorth),<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,shapeEastAndWest),<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,shapeSourceAndNorth)]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> direction1=getDirection(polygon1),direction2=getDirection(polygon2);</div><div class="line">    <span class="keyword">if</span> (direction1[<span class="number">0</span>]&gt;direction2[<span class="number">2</span>]||direction1[<span class="number">2</span>]&lt;direction2[<span class="number">0</span>]||direction1[<span class="number">1</span>]&lt;direction2[<span class="number">3</span>]||direction1[<span class="number">3</span>]&gt;direction2[<span class="number">1</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;;</div><div class="line">checkTwoPolygonByDirection(shape1,shape2);</div></pre></td></tr></table></figure>
</code></pre><p>排除了最多的情况以后，我们就要开始探寻两个多边形相交的算法了。两多边形相交，其中肯定有一个多边形的点在另一个多边形里。我们先往这个方向探寻。</p>
<p>判断一个点是否在多边形内，有一个很有意思的理论。想象有一个点在多边形内，这个点朝任意方向射出一条射线，无论多边形是什么形状，射线经过的点都是奇数。我在前端乱炖上看到一篇文章，讲了射线法的写法和特殊情况的处理，原文地址<a href="http://www.html-js.com/article/1528" target="_blank" rel="external">http://www.html-js.com/article/1528</a>（米粽粽）。</p>
<p>简单的说，点在多边形内的判断有4种特殊情况，1.点在多边形边上，2.点和多边形顶点重合，3.射线经过多边形顶点，4.射线刚好经过多边形的一条边。<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/Slice%201.png" alt=""><br>1，2都很简单，具体可以看原文。3，4的话仔细想一想，判断射线有没有穿过线段其实就是判断线段两个端点分别在射线两侧，假如我们规定射线经过的点都属于射线以上的一侧，如图所示：<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/shexian.png" alt=""><br>线段ab顶点和线段ae顶点对于射线1来说都在两侧，所以射线1穿过了两条线段。线段ab顶点都在射线2上侧，线段bc顶点在射线2两侧，所以射线2穿过了线段bc。我们可以得出点1在多边形外，点2在多边形内。</p>
<p>特殊情况4其实和3是一样的，根据上面的假设，射线连续经过的两个顶点显然都位于射线以上的一侧，因此这种情况看作没有发生穿越就可以了。由于3实际上已经覆盖到这种特例，因此不需要再做特别的处理。</p>
<p>最后我们得出的代码如下：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多边形顶点判断多边形相交</span></div><div class="line"><span class="keyword">var</span> checkTwoPolygonByRay = <span class="function"><span class="keyword">function</span> (<span class="params">polygon1,polygon2</span>) </span>&#123;</div><div class="line">    <span class="comment">//判断多边形顶点在另一个多边形里</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rayCasting</span>(<span class="params">p, poly</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> px = p.x,</div><div class="line">            py = p.y,</div><div class="line">            flag = <span class="literal">false</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = poly.length, j = l - <span class="number">1</span>; i &lt; l; j = i, i++) &#123;</div><div class="line">            <span class="keyword">var</span> sx = poly[i].x,</div><div class="line">                sy = poly[i].y,</div><div class="line">                tx = poly[j].x,</div><div class="line">                ty = poly[j].y</div><div class="line"></div><div class="line">            <span class="comment">// 点与多边形顶点重合</span></div><div class="line">            <span class="keyword">if</span>((sx === px &amp;&amp; sy === py) || (tx === px &amp;&amp; ty === py)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 判断线段两端点是否在射线两侧</span></div><div class="line">            <span class="keyword">if</span>((sy &lt; py &amp;&amp; ty &gt;= py) || (sy &gt;= py &amp;&amp; ty &lt; py)) &#123;</div><div class="line">                <span class="comment">// 线段上与射线 Y 坐标相同的点的 X 坐标</span></div><div class="line">                <span class="keyword">var</span> x = sx + (py - sy) * (tx - sx) / (ty - sy)</div><div class="line">                <span class="comment">// 点在多边形的边上</span></div><div class="line">                <span class="keyword">if</span>(x === px) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 射线穿过多边形的边界</span></div><div class="line">                <span class="keyword">if</span>(x &gt; px) &#123;</div><div class="line">                    flag = !flag</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 射线穿过多边形边界的次数为奇数时点在多边形内</span></div><div class="line">        <span class="keyword">return</span> flag</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; polygon1.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (rayCasting(polygon1[i],polygon2)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; polygon2.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (rayCasting(polygon2[i],polygon1)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p>上面这段代码有什么问题呢？我发现两多边形相交的话其中一个多边形的所有顶点不一定在另一个多边形内，所以我们两个多边形都得遍历一遍，在最坏的情况下性能很差。我们有没有什么办法能用更少时间复杂度的方法来计算呢？</p>
<p>两多边形相交的话是不是一定有两条边相交呢？计算两直线相交有很多种办法，比如利用叉乘，比如利用计算点和线段构成的三角形面积等。</p>
<p>判断两条线相交，需要判断每一条线的两个端点分别在另一条线的两端。通过建立向量，计算叉乘来判断两个值的正负来判断是否在线段两边。具体理论可以看<a href="http://www.html-js.com/article/1183" target="_blank" rel="external">http://www.html-js.com/article/1183</a>（芋头）。</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//两条线相交判断多边形相交</span></div><div class="line"><span class="keyword">var</span> checkTwoPolygonByintersect=<span class="function"><span class="keyword">function</span> (<span class="params">polygon1,polygon2</span>) </span>&#123;</div><div class="line">    <span class="comment">//计算向量叉乘</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">crossMul</span> (<span class="params">v1,v2</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span>   v1.x*v2.y-v1.y*v2.x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//计算两条线是否相交</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkCross</span> (<span class="params">p1,p2,p3,p4</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> (checkTwoCross(p1,p2,p3,p4)&lt;=<span class="number">0</span>&amp;&amp;checkTwoCross(p3,p4,p2,p1)&lt;=<span class="number">0</span>)?<span class="literal">true</span>:<span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//计算两个向量叉乘相乘是否为负 </span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkTwoCross</span> (<span class="params">p1,p2,p3,p4</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> v1=&#123;<span class="attr">x</span>:p1.x-p3.x,<span class="attr">y</span>:p1.y-p3.y&#125;,</div><div class="line">        v2=&#123;<span class="attr">x</span>:p2.x-p3.x,<span class="attr">y</span>:p2.y-p3.y&#125;,</div><div class="line">        v3=&#123;<span class="attr">x</span>:p4.x-p3.x,<span class="attr">y</span>:p4.y-p3.y&#125;,</div><div class="line">        v=crossMul(v1,v3)*crossMul(v2,v3);</div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = polygon1.length, j = l<span class="number">-1</span>; i &lt; l; j=i, i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i2 = <span class="number">0</span>, l2 = polygon2.length, j2 = l2<span class="number">-1</span>; i2 &lt; l; j2=i2, i2++) &#123;</div><div class="line">            <span class="keyword">if</span> (checkCross(polygon1[i],polygon1[j],polygon2[i2],polygon2[j2])) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p>还有很多种方法判断两直线相交，比如点和线段构成的三角形面积。已知三角形三点a(x,y) b(x,y) c(x,y)，三角形面积为：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> triArea=( (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x) ) /<span class="number">2</span> ;</div></pre></td></tr></table></figure>
</code></pre><p>如果线段ab和点c构成的三角形面积与线段ab和点d构成的三角形面积构成的三角形面积的正负符号相异, 那么点c和点d位于线段ab两侧.<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/triangle.png" alt=""><br>感兴趣的可以自己实现。</p>
<p>通过两条线相交来判断多边形相交有什么缺点呢？其实有一种特殊情况我们没有想到过，那就是当一个多边形在另一个多边形内怎么办？难道我们还是得回到原来通过多边形的一个顶点在另一个多边形内来判断么？</p>
<p>不，既然这种算法更优，我们再想办法来覆盖特殊情况。一个多边形在另一个多边形内有一个必要非充分条件，和我们在文章开头读到的算法相似。当多边形a在多边形b内时，多边形b的四个极点都比多边形a大。那我们就可以通过这个条件来减少我们算法的时间复杂度，当满足这个条件时再判断一个多边形是否有个点在另一个多边形内。<br><img src="http://7xtb3a.com2.z0.glb.clouddn.com/insert.png" alt=""><br>我们把开头的算法改造如下：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方向相离判断两多边形不相交</span></div><div class="line"><span class="keyword">var</span> checkTwoPolygonByDirection = <span class="function"><span class="keyword">function</span> (<span class="params">polygon1,polygon2</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDirection</span>(<span class="params">shape</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> shapeEastAndWest = [],shapeSourceAndNorth = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shape.length; i++) &#123;</div><div class="line">            shapeEastAndWest.push(shape[i].lat);</div><div class="line">            shapeSourceAndNorth.push(shape[i].lng);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>[<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,shapeEastAndWest),<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,shapeSourceAndNorth),<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,shapeEastAndWest),<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,shapeSourceAndNorth)]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> direction1=getDirection(polygon1),direction2=getDirection(polygon2);</div><div class="line">    <span class="keyword">if</span> (direction1[<span class="number">0</span>]&gt;direction2[<span class="number">2</span>]||direction1[<span class="number">2</span>]&lt;direction2[<span class="number">0</span>]||direction1[<span class="number">1</span>]&lt;direction2[<span class="number">3</span>]||direction1[<span class="number">3</span>]&gt;direction2[<span class="number">1</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [direction1,direction2]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p>然后完成我们完整的算法：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断两多边形是否相交</span></div><div class="line"><span class="keyword">var</span> checkTwoPolygon = <span class="function"><span class="keyword">function</span> (<span class="params">shape1,shape2</span>) </span>&#123;</div><div class="line">    <span class="comment">//通过极点判断是否相离，相离return true，否则return[多边形1的极点数组，多边形2的极点数组]</span></div><div class="line">    <span class="keyword">var</span> directions = checkTwoPolygonByDirection(shape1,shape2);</div><div class="line">    <span class="keyword">if</span> (directions == <span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通过直线相交来判断多边形是否相交</span></div><div class="line">    <span class="keyword">if</span> (checkTwoPolygonByintersect(shape1,shape2)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通过多边形1的极点都比多边形2的极点小或者都比多边形2的极点大来进入 通过多边形的顶点在另一个多边形内的算法</span></div><div class="line">    <span class="keyword">if</span> ((directions[<span class="number">0</span>][<span class="number">0</span>]&lt;directions[<span class="number">1</span>][<span class="number">0</span>]&amp;&amp;directions[<span class="number">0</span>][<span class="number">1</span>]&gt;directions[<span class="number">1</span>][<span class="number">1</span>]&amp;&amp;directions[<span class="number">0</span>][<span class="number">2</span>]&gt;directions[<span class="number">1</span>][<span class="number">2</span>]&amp;&amp;directions[<span class="number">0</span>][<span class="number">3</span>]&lt;directions[<span class="number">1</span>][<span class="number">3</span>])||(directions[<span class="number">1</span>][<span class="number">0</span>]&lt;directions[<span class="number">0</span>][<span class="number">0</span>]&amp;&amp;directions[<span class="number">1</span>][<span class="number">1</span>]&gt;directions[<span class="number">0</span>][<span class="number">1</span>]&amp;&amp;directions[<span class="number">1</span>][<span class="number">2</span>]&gt;directions[<span class="number">0</span>][<span class="number">2</span>]&amp;&amp;directions[<span class="number">1</span>][<span class="number">3</span>]&lt;directions[<span class="number">0</span>][<span class="number">3</span>])) &#123;</div><div class="line">        <span class="keyword">return</span> checkTwoPolygonByRay(shape1,shape2)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p>这个并不完美的算法就算完成了，它还有很多不完美的地方，如果大家有什么更好的idea欢迎联系我.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在业务中有个需求是用高德api绘制多个多边形，且多边形不能有重合的地方。高德并没有提供这种api，所以自己尝试着实现了一个算法。&lt;/p&gt;
&lt;p&gt;判断两个多边形是否相交，首先从业务需求来想，最多的情况肯定是两个多边形不相交，从这个角度想的话，有什么情况下两个多边形一定不相
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.huangkaiyi.me/tags/javascript/"/>
    
  </entry>
  
</feed>
